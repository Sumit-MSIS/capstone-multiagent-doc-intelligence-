import asyncio
from src.common.sql_retriever.sql_handler import get_distinct_contract_types
from src.common.logger import _log_message
from src.config.base_config import config
from typing import List, Dict, Any
from src.intel.services.intel_chat.agent.async_db_connection_manager import DBConnectionManager
import mlflow
import json
import time
from jinja2 import Template

mlflow.openai.autolog()
from opentelemetry import context as ot_context
from mlflow.entities import SpanType
from src.common.token_cost_tracker import (
    record_llm_usage, get_total_cost, calculate_model_cost
)

from src.common.llm.factory import get_llm_client

OPENAI_MODEL_NAME = config.OPENAI_MODEL_NAME
CONTRACT_GENERATION_DB = config.CONTRACT_GENERATION_DB
CONTRACT_INTEL_DB = config.CONTRACT_INTEL_DB
SQL_AGENT_LLM_MODEL_NAME= "gpt-4o"
SQL_AGENT_LLM_TEMPERATURE=0.1
module_name = "sql_agent"

import logging
logger = logging.getLogger("sql_agent")

@mlflow.trace(name="analytical_sql_tool")
async def sql_tool(file_ids: List[str], chat_id: int, question: str, org_id: int, user_id: int, tag_ids: List[str]):
    try:
        current_date = time.strftime("%Y-%m-%d")

        if await create_contracts_view_for_agent(org_id, user_id, tag_ids, logger):
            logger.info(_log_message("View created successfully!", "sql_agent", module_name))

        distinct_contract_type_list = await asyncio.to_thread(get_distinct_contract_types, org_id, logger)

        with open("src/intel/services/intel_chat/agent/tools/sql_prompt.yaml") as f:
            template = Template(f.read())

        system_prompt = template.render(
            current_date=str(current_date),
            ci_file_guids=str(file_ids),
            org_id=f"{org_id}_{user_id}",
            distinct_contract_type_list=str(distinct_contract_type_list)
        )

        user_prompt = f"""
        <instruction>
        Generate an SQL query to filter ci_file_guid and file_name from file_metadata_view_{org_id}_{user_id}
        based on the following user question:
        </instruction>
        <user_question>
        {question}
        </user_question>
        <output_format>
        - Return SQL only OR an empty list
        - No markdown, no explanation
        - Must include ci_file_guid and file_name
        </output_format>
        """

        schema = {
            "type": "json_schema",
            "json_schema": {
                "name": "analytical_sql",
                "schema": {
                    "type": "object",
                    "properties": {
                        "sql_query": {"type": "string"}
                    },
                    "required": ["sql_query"],
                    "additionalProperties": False
                },
                "strict": True
            }
        }

        client = get_llm_client(async_mode=True)

        llm_response = await client.chat.completions.create(
            model=SQL_AGENT_LLM_MODEL_NAME,
            temperature=SQL_AGENT_LLM_TEMPERATURE,
            top_p=1,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            response_format=schema
        )

        parsed = json.loads(llm_response.choices[0].message.content)
        sql_query = parsed.get("sql_query")

        if not sql_query or sql_query.strip() == "[]":
            return [], False

        logger.info(_log_message(f"Generated SQL: {sql_query}", "sql_agent", module_name))

        # Log token usage
        record_llm_usage(
            chat_id=chat_id,
            model_name=SQL_AGENT_LLM_MODEL_NAME,
            input=llm_response.usage.prompt_tokens,
            output=llm_response.usage.completion_tokens,
            cache=llm_response.usage.prompt_tokens_details.cached_tokens
        )

        # Execute SQL and return results instead of file IDs
        results = await execute_sql_query(sql_query)

        if results:
            return results, True
        return [], False

    except Exception as e:
        logger.error(_log_message(f"SQL Agent error: {str(e)}", "sql_agent", module_name))
        return [], False


@mlflow.trace(name="Fetch metadata for SQL Agent")
async def execute_sql_query(query: str):
    """
    Executes any analytical SQL query generated by SQL agent and returns raw results.

    Args:
        query (str): Generated SQL query.
        org_id (str): Organization ID.
        logger (logging.Logger): Logger instance.

    Returns:
        list: Query result rows (list of dicts) or empty list on failure.
    """
    try:
        async with DBConnectionManager(CONTRACT_INTEL_DB) as conn:
            async with conn.cursor() as cursor:

                await cursor.execute(query)
                result = await cursor.fetchall()

                # No result case
                if not result:
                    return []

                # Valid result - return directly
                if isinstance(result, list) and all(isinstance(row, dict) for row in result):
                    return result

                return []

    except Exception as e:
        return []


@mlflow.trace(name="Check File ID Present")
async def is_file_id_present(file_ids: List[str], only_contract, tag_ids, logger) -> List[str]:
    """
    Checks whether given file IDs exist in the database and are not archived.

    :param file_ids: List of file IDs to check.
    :param user_id: User ID making the request.
    :param org_id: Organization ID.
    :param logger: Logger instance.
    :return: List of matching file IDs found in the database.
    """
    start_time = time.perf_counter()

    if not isinstance(file_ids, list) or not all(isinstance(file_id, str) for file_id in file_ids):
        logger.error(_log_message(f"Input Error: 'file_ids' must be a list of strings.", "is_file_id_present", module_name))
        return []

    try:

        # Step 1: Get file_temp_ids values from file_tags
        async with DBConnectionManager(CONTRACT_INTEL_DB) as conn:
            async with conn.cursor() as cursor:
                await cursor.execute(
                    """
                    SELECT file_temp_id 
                    FROM file_tags 
                    WHERE tag_id IN %s
                    """,
                    (tuple(tag_ids),)
                )
                file_temp_ids = [row["file_temp_id"] for row in await cursor.fetchall()]  # collect as list

        if not file_temp_ids:
            logger.info(_log_message("No temp file IDs found for given tags.", "is_file_id_present", module_name))
            return []

        logger.info(_log_message(f"Temp file IDs from tags: {file_temp_ids}", "is_file_id_present", module_name))

        file_ids = [fid for fid in file_ids if fid in file_temp_ids] if file_ids else []

        if not file_ids:
            logger.info(_log_message("No matching file IDs found after filtering with tags.", "is_file_id_present", module_name))
            return []


        async with DBConnectionManager(CONTRACT_INTEL_DB) as connection:
            logger.info(_log_message(f"Checking file IDs in repository | File IDs: {file_ids}", "is_file_id_present", module_name))
            
            async with connection.cursor() as cursor:
                query = """
                SELECT ci_file_guid 
                FROM files 
                WHERE ci_file_guid IN %s 
                AND is_archived IS NULL;
                """ if not only_contract else """
                SELECT ci_file_guid 
                FROM files 
                WHERE ci_file_guid IN %s 
                AND is_archived IS NULL AND is_template IN (0, 2) AND name not like "temp/%%";
                """
                await cursor.execute(query, (tuple(file_ids),))
                records = await cursor.fetchall()

                matching_file_ids = [record["ci_file_guid"] for record in records]

                execution_time = time.perf_counter() - start_time
                logger.info(_log_message(f"Found {len(matching_file_ids)} matching file IDs. Execution time: {execution_time:.4f} seconds.", "is_file_id_present", module_name))
                return matching_file_ids

    except Exception as e:
        logger.error(_log_message(f"Error in is_file_id_present: {e}", "is_file_id_present", module_name))
        return []



@mlflow.trace(name="Create Contract Only View for SQL Agent")
async def create_contracts_view_for_agent(org_id: str, user_id: str, tag_ids: List[str], logger) -> bool:
    """
    Creates a view in the MySQL database for the SQL agent.

    Args:
        user_id (str): User ID for logging.
        org_id (str): Organization ID.
        logger (logging.Logger): Logger instance.

    Returns:
        bool: True if the view was created successfully, False otherwise.
    """
    try:
        async with DBConnectionManager(CONTRACT_INTEL_DB) as conn:
            async with conn.cursor() as cursor:

                # Query to create the view
                create_view_query = f"""
                    CREATE VIEW file_metadata_view_{org_id}_{user_id} AS
                        WITH metadata_pivot AS (
                            SELECT 
                                fm.ci_file_guid,
                                MAX(CASE WHEN fm.metadata_title = 'Title of the Contract' THEN CAST(fm.metadata_text_value AS CHAR CHARACTER SET utf8mb4) COLLATE utf8mb4_unicode_ci END) AS title_of_contract,
                                MAX(CASE WHEN fm.metadata_title = 'Scope of Work' THEN CAST(fm.metadata_text_value AS CHAR CHARACTER SET utf8mb4) COLLATE utf8mb4_unicode_ci END) AS scope_of_Work,
                                MAX(CASE WHEN fm.metadata_title = 'Parties Involved' THEN CAST(fm.metadata_text_value AS CHAR CHARACTER SET utf8mb4) COLLATE utf8mb4_unicode_ci END) AS party_name,
                                MAX(CASE WHEN fm.metadata_title = 'Contract Type' THEN CAST(fm.metadata_text_value AS CHAR CHARACTER SET utf8mb4) COLLATE utf8mb4_unicode_ci END) AS contract_type,
                                MAX(CASE WHEN fm.metadata_title = 'File Type' THEN CAST(fm.metadata_text_value AS CHAR CHARACTER SET utf8mb4) COLLATE utf8mb4_unicode_ci END) AS file_type,
                                MAX(CASE WHEN fm.metadata_title = 'Jurisdiction' THEN CAST(fm.metadata_text_value AS CHAR CHARACTER SET utf8mb4) COLLATE utf8mb4_unicode_ci END) AS jurisdiction,
                                MAX(CASE WHEN fm.metadata_title = 'Version Control' THEN CAST(fm.metadata_text_value AS CHAR CHARACTER SET utf8mb4) COLLATE utf8mb4_unicode_ci END) AS version_control,
                                MAX(CASE WHEN fm.metadata_title = 'Contract Duration' THEN CAST(SUBSTRING_INDEX(fm.metadata_text_value, ' ', 1) AS DECIMAL(10,1)) END) AS contract_duration,
                                MAX(
                                    CASE 
                                        WHEN fm.metadata_title = 'Contract Value'
                                        THEN COALESCE(
                                            CAST(fm.metadata_decimal_value AS CHAR),
                                            fm.metadata_text_value
                                        ) COLLATE utf8mb4_unicode_ci
                                    END
                                ) AS contract_value,
                                MAX(CASE WHEN fm.metadata_title = 'Risk Mitigation Score' THEN fm.metadata_decimal_value END) AS risk_mitigation_score
                            FROM file_metadata fm
                            GROUP BY fm.ci_file_guid
                        ),
                        date_pivot AS (
                            SELECT 
                                fmd.ci_file_guid,
                                MAX(CASE WHEN fmd.date_title = 'Effective Date' THEN fmd.date_value END) AS effective_date,
                                MAX(CASE WHEN fmd.date_title = 'Term Date' THEN fmd.date_value END) AS term_date,
                                MAX(CASE WHEN fmd.date_title = 'Payment Due Date' THEN fmd.date_value END) AS payment_due_date,
                                MAX(CASE WHEN fmd.date_title = 'Delivery Date' THEN fmd.date_value END) AS delivery_date,
                                MAX(CASE WHEN fmd.date_title = 'Termination Date' THEN fmd.date_value END) AS termination_date,
                                MAX(CASE WHEN fmd.date_title = 'Renewal Date' THEN fmd.date_value END) AS renewal_date,
                                MAX(CASE WHEN fmd.date_title = 'Expiration Date' THEN fmd.date_value END) AS expiration_date
                            FROM file_metadata_dates fmd
                            GROUP BY fmd.ci_file_guid
                        )
                        SELECT 
                            f.ci_file_guid,
                            f.name AS file_name,
                            f.user_id AS created_by,
                            f.created_date AS uploaded_date,
                            mp.title_of_contract,
                            mp.scope_of_Work,
                            mp.party_name,
                            mp.contract_type,
                            mp.file_type,
                            mp.jurisdiction,
                            mp.version_control,
                            mp.contract_duration,
                            mp.contract_value,
                            mp.risk_mitigation_score,
                            dp.effective_date,
                            dp.term_date,
                            dp.payment_due_date,
                            dp.delivery_date,
                            dp.termination_date,
                            dp.renewal_date,
                            dp.expiration_date
                        FROM (
                            SELECT DISTINCT ci_file_guid, name, user_id, created_date
                            FROM files 
                            WHERE ci_org_guid IN (SELECT ci_org_guid FROM organizations WHERE org_id = {org_id}) 
                            AND is_archived IS NULL AND type = 1 AND name not like 'temp/%' AND is_template IN (0, 2)
                            AND ci_file_guid IN (SELECT file_temp_id FROM file_tags WHERE tag_id IN ({', '.join(map(str, tag_ids))}))
                        ) f
                        LEFT JOIN metadata_pivot mp ON f.ci_file_guid = mp.ci_file_guid
                        LEFT JOIN date_pivot dp ON f.ci_file_guid = dp.ci_file_guid;"""
                
                logger.info(_log_message("Executing query to create view for SQL agent.", "create_view_for_agent", module_name))


                # Execute the query
                await cursor.execute(create_view_query)
                await conn.commit()
                logger.info(_log_message("View created successfully for SQL agent.", "create_view_for_agent", module_name))
                return True
    except Exception as e:
        logger.error(_log_message(f"Error creating view for SQL agent: {str(e)}", "create_view_for_agent", module_name))
        return False